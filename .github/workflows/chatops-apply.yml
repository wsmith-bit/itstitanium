name: Apply patch from comment

on:
  issue_comment:
    types: [created]
  workflow_dispatch: {}  # allow manual runs for testing

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  apply:
    # Run if manual OR the comment body contains /apply anywhere
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'issue_comment' &&
       contains(github.event.comment.body, '/apply'))
    runs-on: ubuntu-latest

    steps:
      - name: Show event context
        run: |
          echo "event=${{ github.event_name }}"
          echo "actor=${{ github.actor }}"
          echo "repo=${{ github.repository }}"
          echo "ref=${{ github.ref }}"

      - name: Dump event payload (JSON)
        uses: actions/github-script@v7
        with:
          script: |
            console.log(JSON.stringify(context.payload, null, 2))

      - name: Show comment body (if any)
        if: github.event_name == 'issue_comment'
        env:
          BODY: ${{ github.event.comment.body }}
        run: |
          echo '---- COMMENT BODY START ----'
          echo "$BODY" | sed -e 's/^/| /'
          echo '---- COMMENT BODY END ----'

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure git identity
        run: |
          git config user.name  "itstitanium-bot"
          git config user.email "bot@users.noreply.github.com"

      - name: Extract fenced blocks
        id: extract
        if: github.event_name == 'issue_comment'
        env:
          BODY: ${{ github.event.comment.body }}
        run: |
          python - << 'PY'
          import os, re, sys, json, pathlib
          body = os.environ.get('BODY','')

          # Capture diff block
          m_diff = re.search(r'```diff\s*(.*?)```', body, re.S|re.M)
          if m_diff:
              patch = m_diff.group(1)
              pathlib.Path('/tmp/ai.patch').write_text(patch, encoding='utf-8')
              print("WROTE /tmp/ai.patch")

          # Capture replace block
          m_rep = re.search(r'```replace\s*(.*?)```', body, re.S|re.M)
          if m_rep:
              block = m_rep.group(1).strip()
              cfg = {}
              for line in block.splitlines():
                  if ':' not in line: 
                      continue
                  k,v = line.split(':',1)
                  cfg[k.strip().lower()] = v.strip()
              need = {'file','find','replace'}
              if need.issubset(cfg):
                  pathlib.Path('/tmp/replace.json').write_text(json.dumps(cfg), encoding='utf-8')
                  print("WROTE /tmp/replace.json")
              else:
                  print("::warning::replace block missing required keys (file, find, replace).")

          if not m_diff and not m_rep:
              print("::error::No fenced ```diff``` or ```replace``` block found.")
              sys.exit(1)
          PY

      - name: Apply git diff patch (if provided)
        if: github.event_name == 'issue_comment' && hashFiles('/tmp/ai.patch') != ''
        run: |
          set -xe
          git apply --check /tmp/ai.patch || { echo "::error::git apply --check failed"; exit 1; }
          git apply --whitespace=fix /tmp/ai.patch
          git status --porcelain

      - name: Apply replace block (fallback)
        if: github.event_name == 'issue_comment' && hashFiles('/tmp/ai.patch') == '' && hashFiles('/tmp/replace.json') != ''
        run: |
          set -e
          python - << 'PY'
          import json, os, sys
          from pathlib import Path
          cfg = json.loads(Path('/tmp/replace.json').read_text(encoding='utf-8'))
          path = Path(cfg['file'])
          if not path.exists():
              print(f"::error::File not found: {path}")
              sys.exit(1)
          text = path.read_text(encoding='utf-8')
          find = cfg['find']
          repl = cfg['replace']
          if find not in text:
              print("::error::Find string not present in file.")
              sys.exit(1)
          new = text.replace(find, repl, 1)
          path.write_text(new, encoding='utf-8')
          print(f"Replaced once in {path}")
          PY
          git add -A

      - name: Seed head assets across public HTML
        run: node scripts/update-head-assets.js

      - name: Commit & push branch
        run: |
          set -e
          BRANCH="ai/update-${{ github.run_id }}"
          git checkout -b "$BRANCH"
          git add -A
          if git diff --cached --quiet; then
            git commit --allow-empty -m "AI patch (empty commit) ${{ github.run_id }}"
          else
            git commit -m "AI patch from comment or manual run ${{ github.run_id }}"
          fi
          git push -u origin "$BRANCH"

      - name: Open PR via API
        uses: actions/github-script@v7
        with:
          script: |
            const branch = `ai/update-${process.env.GITHUB_RUN_ID}`;
            const {owner, repo} = context.repo;
            const res = await github.rest.pulls.create({
              owner, repo,
              title: `AI patch ${process.env.GITHUB_RUN_ID}`,
              head: branch,
              base: 'main',
              body: `Source: ${context.serverUrl}/${owner}/${repo}\nEvent: ${context.eventName}`
            });
            core.info(`PR #${res.data.number}: ${res.data.html_url}`);
